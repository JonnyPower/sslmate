#!/usr/bin/env perl

#
# Copyright (c) 2014 Opsmate, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name(s) of the above copyright
# holders shall not be used in advertising or otherwise to promote the
# sale, use or other dealings in this Software without prior written
# authorization.
#

#
# This program is designed to be used with the online SSLMate service at
# <https://sslmate.com/>.  Use of the SSLMate service is governed by the
# Terms and Conditions available online at <https://sslmate.com/terms>.
#

use 5.010;	# 5.10
use strict;
use warnings;
use Getopt::Long;
use Errno;
use Fcntl;
use POSIX ":sys_wait_h";
use Cwd qw(realpath);
use Digest::SHA qw(sha256_hex);
use File::Basename;
use File::Temp;
use IO::Handle;
use IPC::Open2;

				# Debian/Ubuntu package		RHEL/CentOS package
				# --------------------------------------------------
# WWW::Curl::Easy		# libwww-curl-perl		perl-WWW-Curl
use URI::Escape;		# liburi-perl			perl-URI
use JSON::PP; # core in 5.13.9+	# libjson-perl			perl-JSON
use Term::ReadKey;		# libterm-readkey-perl		perl-TermReadKey

our $has_curl = eval { require WWW::Curl::Easy; 1 };

use version; our $VERSION = version->declare('0.6.2');
our $API_ENDPOINT = 'https://sslmate.com/api/v1';

our $quiet = 0;
our $config_profile;
our %global_config;
our %personal_config;
our %ephemeral_config;
our $curl;

sub print_usage {
	my ($out) = @_;

	#          |--------------------------------------------------------------------------------| 80 chars
	print $out "Usage: sslmate [OPTIONS] COMMAND [ARGS]\n";
	print $out "\n";
	print $out "Commands:\n";
	print $out " sslmate buy HOSTNAME             Buy a certificate for the given hostname\n";
	print $out " sslmate renew HOSTNAME           Renew the certificate for the given hostname\n";
	print $out " sslmate reissue HOSTNAME         Reissue the certificate for given hostname\n";
	print $out " sslmate revoke [-a] HOSTNAME     Revoke the certificate for given hostname\n";
	print $out " sslmate download HOSTNAME        Download the certificate for given hostname\n";
	#print $out " sslmate import KEYFILE CERTFILE  Import this certificate to your account\n";
	print $out " sslmate test HOSTNAME            Check if the certificate is properly installed\n";
	print $out " sslmate mkconfig TEMPLATE NAME   Generate configuration for the certificate\n";
	print $out " sslmate link                     Link this system with your SSLMate account\n";
	print $out " sslmate help                     Display help\n";
	print $out " sslmate version                  Print the version of SSLMate that's installed\n";
	print $out "\n";
	print $out "Valid options:\n";
	print $out " -p, --profile=NAME               Use the given configuration profile\n";
	print $out "\n";
	print $out "Run 'sslmate help COMMAND' for more information on a specific command.\n";
}

sub new_curl {
	my $curl = WWW::Curl::Easy->new;
	$curl->setopt(WWW::Curl::Easy::CURLOPT_PROTOCOLS(), 3);		# Only safe protocols (HTTP and HTTPS, not SMTP, SSH, etc.)
	$curl->setopt(WWW::Curl::Easy::CURLOPT_FOLLOWLOCATION(), 1);	# Follow redirects
	$curl->setopt(WWW::Curl::Easy::CURLOPT_MAXREDIRS(), 20);	# Allow at most 20 redirections
	$curl->setopt(WWW::Curl::Easy::CURLOPT_SSL_VERIFYPEER(), 1);	# Check certificates
	$curl->setopt(WWW::Curl::Easy::CURLOPT_SSL_VERIFYHOST(), 2);	# Check certificates (2 is not a typo)
	$curl->setopt(WWW::Curl::Easy::CURLOPT_USERAGENT(), "SSLMate/$VERSION");
	return $curl;
}

sub prompt_user {
	my ($message) = @_;

	print $message;
	my $answer = <STDIN>;
	die "Error: Input ended prematurely.\n" unless defined($answer);
	chomp $answer;
	return $answer;
}

sub prompt_yesno {
	while (defined(my $answer = prompt_user("Enter yes or no: "))) {
		if ($answer eq 'yes') {
			return 1;
		} elsif ($answer eq 'no') {
			return 0;
		} else {
			print "I did not understand that.\n";
		}
	}
}

sub prompt_password {
	my ($message) = @_;

	print $message;

	my $password = '';
	ReadMode(4);
	my %ctrl = GetControlChars;
	while (defined(my $key = ReadKey(0))) {
		if ($key eq "\n" || $key eq "\r" || $key eq $ctrl{EOF}) { # e.g. Ctrl+D
			print "\n";
			last;
		} elsif ($key eq $ctrl{INTERRUPT}) { # e.g. Ctrl+C
			$password = undef;
			last;
		} elsif ($key eq $ctrl{ERASE}) {
			if ($password ne '') {
				chop $password;
				print "\b \b";
			}
		} elsif ($key eq $ctrl{KILL} || $key eq $ctrl{ERASEWORD}) { # e.g. Ctrl+U, Ctrl+W
			while ($password ne '') {
				chop $password;
				print "\b \b";
			}
		} else {
			$password = $password . $key;
			print "*";
		}
	}
	ReadMode(0);

	return $password;
}

sub config_has {
	my ($name) = @_;

	return defined $ephemeral_config{$name} || defined $personal_config{$name} || defined $global_config{$name};
}

sub get_config {
	my ($name, $default_value) = @_;

	return $ephemeral_config{$name} if defined $ephemeral_config{$name};
	return $personal_config{$name} if defined $personal_config{$name};
	return $global_config{$name}   if defined $global_config{$name};

	return $default_value;
}

sub migrate_config_option {
	my ($config_ref, $old_name, $new_name) = @_;

	if (exists $config_ref->{$old_name}) {
		$config_ref->{$new_name} = $config_ref->{$old_name} unless exists $config_ref->{$new_name};
		delete $config_ref->{$old_name};
	}
}

sub read_config_file {
	my ($filename) = @_;

	open(my $config_fh, '<', $filename) or die "Error: Unable to open $filename for reading: $!\n";
	my %config_hash = map { my @f = split(' ', $_, 2); $f[0] => $f[1] } grep(/^[^#]/, map { chomp; $_ } <$config_fh>);
	close($config_fh);
	migrate_config_option(\%config_hash, 'api-endpoint', 'api_endpoint');
	migrate_config_option(\%config_hash, 'account-id', 'account_id');
	migrate_config_option(\%config_hash, 'api-key', 'api_key');
	return %config_hash;
}
sub write_config_file {
	my ($filename, $config_ref) = @_;
	
	sysopen(my $config_fh, $filename, O_WRONLY | O_TRUNC | O_CREAT, 0600) or die "Error: Unable to open $filename for writing: $!\n";
	for my $param_name (keys %$config_ref) {
		print $config_fh $param_name . ' ' . $config_ref->{$param_name} . "\n";
	}
	close($config_fh);
}
sub get_personal_config_path {
	return $ENV{'SSLMATE_CONFIG'} if $ENV{'SSLMATE_CONFIG'};
	return $ENV{'HOME'} . '/.sslmate' . ($config_profile ? "-$config_profile" : "") if $ENV{'HOME'};
	die "Error: Neither \$SSLMATE_CONFIG nor \$HOME environment variables set.\n";
}
sub get_global_config_path {
	return '/etc/sslmate' . ($config_profile ? "-$config_profile" : "") . '.conf';
}
sub load_config {
	# Personal config
	%personal_config = ();

	my $personal_config_path = get_personal_config_path;
	if (-e $personal_config_path) {
		%personal_config = read_config_file($personal_config_path);
	}

	# Global config
	%global_config = ();

	my $global_config_path = get_global_config_path;
	# global config file might be readable only by root, so only attempt
	# to access if it's readable.
	if (-r $global_config_path) {
		%global_config = read_config_file($global_config_path);
	}
}
sub save_config {
	write_config_file(get_personal_config_path, \%personal_config);
}
sub is_linked {
	return config_has('account_id') && config_has('api_key');
}

sub init_default_paths {
	my ($do_mkdir) = @_;
	$do_mkdir //= 1;
	if (!config_has("key_directory") && !config_has("cert_directory")) {
		if ($> == 0) {
			my $default_directory = '/etc/sslmate' . ($config_profile ? "-$config_profile" : "");
			if ($do_mkdir && !mkdir($default_directory, 0755)) {
				die "Error: Unable to create $default_directory: $!\n" unless $!{EEXIST};
			}
			$global_config{'key_directory'} = $default_directory;
			$global_config{'cert_directory'} = $default_directory;
		}
	}
	unless (get_config('honor_umask', 'no') eq 'yes') {
		umask 0022;
	}
}

sub file_contents_are {
	my ($filename, $contents) = @_;
	open(my $fh, '<', $filename) or return 0;
	my $actual_contents = do { local $/; <$fh> };
	return $actual_contents eq $contents;
}

sub read_first_crt {
	my ($fh) = @_;
	my $crt = '';
	while (defined(my $line = <$fh>)) {
		chomp $line;
		$crt .= $line;
		$crt .= "\n";
		last if $line eq '-----END CERTIFICATE-----';
	}
	return $crt;
}

sub make_openssl_req_cnf {
	my ($dn) = @_;
	my $tempfile = File::Temp->new();
	print $tempfile <<EOF;
[ req ]
distinguished_name	= req_distinguished_name
prompt			= no
[ req_distinguished_name ]
EOF
	for my $component (qw/C ST L O OU CN/) {
		print $tempfile $component . " = " . $dn->{$component} . "\n" if defined $dn->{$component};
	}
	close $tempfile;
	return $tempfile;
}

sub get_cert_paths {
	my ($cn, $key_too) = @_;

	my $key_directory = config_has("key_directory") ? get_config("key_directory") . "/" : "";
	my $cert_directory = config_has("cert_directory") ? get_config("cert_directory") . "/" : "";

	my $paths = {};
	if ($key_too) {
		$paths->{key_filename} = $key_directory . $cn . ".key";
	}
	$paths->{crt_filename} = $cert_directory . $cn . ".crt";
	$paths->{chain_crt_filename} = $cert_directory . $cn . ".chain.crt";
	$paths->{chained_crt_filename} = $cert_directory . $cn . ".chained.crt";
	return $paths;
}

sub check_for_existing_files {
	my @filenames = @_;

	my $already_exists = 0;
	for my $filename (@filenames) {
		if (defined $filename && -e $filename) {
			print STDERR "Error: a file named '$filename' already exists.\n";
			$already_exists++;
		}
	}
	if ($already_exists) {
		die "Please move/remove " . ($already_exists == 1 ? "this file" : "these files") . (!config_has("key_directory") && !config_has("cert_directory") ? " or run sslmate from a different directory" : "") . ".\n";
	}
}

sub open_key_file {
	my ($filename, $overwrite) = @_;

	my $flags = O_WRONLY | O_CREAT;
	$flags |= O_EXCL unless $overwrite;

	my $fh;
	sysopen($fh, $filename, $flags, 0600)
		or die "Error: unable to open '$filename' for writing: $!\n";
	return $fh;
}

sub write_cert_files {
	my ($paths, $new_key_filename, $crt, $chain) = @_;

	# write .crt file
	my $crt_file = File::Temp->new(DIR => dirname($paths->{crt_filename}), TEMPLATE => '.sslmate.XXXXXX');
	chmod(0666 & ~umask, $crt_file);
	print $crt_file $crt;
	close $crt_file;

	# write .chain.crt file
	my $chain_crt_file = File::Temp->new(DIR => dirname($paths->{crt_filename}), TEMPLATE => '.sslmate.XXXXXX');
	chmod(0666 & ~umask, $chain_crt_file);
	print $chain_crt_file $chain;
	close $chain_crt_file;

	# write .chained.crt file
	my $chained_crt_file = File::Temp->new(DIR => dirname($paths->{crt_filename}), TEMPLATE => '.sslmate.XXXXXX');
	chmod(0666 & ~umask, $chained_crt_file);
	print $chained_crt_file $crt;
	print $chained_crt_file $chain;
	close $chained_crt_file;

	# Rename the new files on top of the old files:
	if (defined $new_key_filename && $new_key_filename ne $paths->{key_filename}) {
		rename($new_key_filename, $paths->{key_filename})
				or die "Error: " . $paths->{key_filename} . ': ' . $! . "\n";
	}

	rename($crt_file->filename, $paths->{crt_filename})
				or die "Error: " . $paths->{crt_filename} . ': ' . $! . "\n";
	$crt_file->unlink_on_destroy(0);

	rename($chain_crt_file->filename, $paths->{chain_crt_filename})
			or die "Error: " . $paths->{chain_crt_filename} . ': ' . $! . "\n";
	$chain_crt_file->unlink_on_destroy(0);

	rename($chained_crt_file->filename, $paths->{chained_crt_filename})
			or die "Error: " . $paths->{chained_crt_filename} . ': ' . $! . "\n";
	$chained_crt_file->unlink_on_destroy(0);
}

sub qs_escape {
	my ($str) = @_;
	return uri_escape_utf8($str, '^A-Za-z0-9\-\._');
}

sub native_api_call {
	my ($method, $command, $request_data) = @_;

	$curl //= new_curl;
	if ($method eq 'GET') {
		$command .= "?$request_data" if $request_data;
		$curl->setopt(WWW::Curl::Easy::CURLOPT_HTTPGET(), 1);
	} elsif ($method eq 'POST') {
		$curl->setopt(WWW::Curl::Easy::CURLOPT_POSTFIELDS(), $request_data);
		$curl->setopt(WWW::Curl::Easy::CURLOPT_POSTFIELDSIZE(), length $request_data);
	}
	$curl->setopt(WWW::Curl::Easy::CURLOPT_URL(), (get_config('api_endpoint') // $API_ENDPOINT) . $command);

	my $response_data = '';
	open(my $response_fh, '>', \$response_data);
	$curl->setopt(WWW::Curl::Easy::CURLOPT_WRITEDATA(), $response_fh);

	my $result = $curl->perform;
	close($response_fh);
	if ($result != 0) {
		print STDERR "Error: unable to contact SSLMate server: " . $curl->strerror($result) . "\n";
		undef $curl;
		return undef;
	}
	my $http_status = $curl->getinfo(WWW::Curl::Easy::CURLINFO_HTTP_CODE());
	my $content_type = $curl->getinfo(WWW::Curl::Easy::CURLINFO_CONTENT_TYPE());

	return ($http_status, $content_type, \$response_data);
}

sub escape_curl_param {
	my ($param) = @_;
	$param =~ s/\\/\\\\/g;
	$param =~ s/\"/\\\"/g;
	$param =~ s/\t/\\t/g;
	$param =~ s/\n/\\n/g;
	$param =~ s/\r/\\r/g;
	$param =~ s/\v/\\v/g;
	return $param;
}

sub decode_curl_error {
	my ($exit_code) = @_;

	return "Unable to resolve server address" if $exit_code == 6;
	return "Unable to connect to server" if $exit_code == 7;
	return "Timeout" if $exit_code == 28;
	return "SSL handshake failed" if $exit_code == 35;
	return "SSL certificate error" if $exit_code == 51;
	return "SSL certificate cannot be authenticated" if $exit_code == 60;

	return "curl exited with status $exit_code";
}

sub external_api_call {
	my ($method, $command, $request_data) = @_;

	local $SIG{PIPE} = 'IGNORE';

	if ($method eq 'GET') {
		$command .= "?$request_data" if $request_data;
	}

	my ($response_fh, $config_fh);
	my $curl_pid = eval { open2($response_fh, $config_fh, 'curl', '-K', '-') };
	die "Error: Unable to execute the 'curl' command - is curl installed?\n" unless defined($curl_pid);
	print $config_fh "user-agent = \"" . escape_curl_param("SSLMate-external/$VERSION") . "\"\n";
	print $config_fh "silent\n";
	print $config_fh "include\n";
	print $config_fh "url = \"" . escape_curl_param((get_config('api_endpoint') // $API_ENDPOINT) . $command) . "\"\n";
	if ($method eq 'POST') {
		print $config_fh "data = \"" . escape_curl_param($request_data) . "\"\n";
	}
	close($config_fh);

	my ($http_status, $content_type, $response_data);
	if (!eof($response_fh)) {
		do {
			# HTTP/1.1 200 OK
			my $http_status_line = <$response_fh>;
			$http_status_line =~ s/\r?\n$//;
			(undef, $http_status, undef) = split(' ', $http_status_line);

			# Content-Type: application/json
			$content_type = undef;
			while (defined(my $line = <$response_fh>)) {
				$line =~ s/\r?\n$//;
				last if $line eq ''; # end of headers
				if ($line =~ /^Content-Type:\s*(.*)$/i) {
					$content_type = $1;
				}
			}
		} while ($http_status == 100);

		$response_data = do { local $/; <$response_fh> };
	}
	close($response_fh);
	waitpid($curl_pid, 0) or die "waitpid failed: $!";
	if ($? != 0) {
		if (WIFEXITED($?)) {
			print STDERR "Error: unable to contact SSLMate server: " . decode_curl_error(WEXITSTATUS($?)) . "\n";
		} else {
			print STDERR "Error: unable to contact SSLMate server: curl terminated with status $?\n";
		}
		return undef;
	}
	if (not $http_status) {
		print STDERR "Error: unable to contact SSLMate server: curl produced unexpected output\n";
		return undef;
	}

	return ($http_status, $content_type, \$response_data);
}

sub api_call {
	my ($method, $command, $request_data) = @_;

	if (ref($request_data) eq 'HASH') {
		# Convert into a query string
		my @elts;
		for my $key (keys %$request_data) {
			next unless defined $request_data->{$key};
			if (ref($request_data->{$key}) eq 'ARRAY') {
				for my $value (@{$request_data->{$key}}) {
					next unless defined $value;
					push @elts, qs_escape($key) . '=' . qs_escape($value);
				}
			} else {
				push @elts, qs_escape($key) . '=' . qs_escape($request_data->{$key});
			}
		}
		$request_data = join('&', @elts);
	}

	my ($http_status, $content_type, $response_data) = $has_curl ?
				native_api_call($method, $command, $request_data) :
				external_api_call($method, $command, $request_data);

	return undef unless defined($http_status);

	$content_type //= '';

	if ($content_type ne 'application/json') {
		print STDERR "Error: received unexpected response from SSLMate server: response not JSON (content-type=$content_type; status=$http_status)\n";
		return undef;
	}
	
	my $response_obj = eval { decode_json($$response_data) };
	if (!defined($response_obj)) {
		chomp $@;
		print STDERR "Error: received malformed response from SSLMate server: $@\n";
		return undef;
	}
	if (!defined($response_obj->{status})) {
		print STDERR "Error: received invalid response from SSLMate server: no status field\n";
		return undef;
	}
	return $response_obj;
}

sub openssl_genrsa {
	my ($key_file, $nbits) = @_;

	my $openssl_pid = fork;
	die "Error: fork failed: $!" unless defined $openssl_pid;
	if ($openssl_pid == 0) {
		open(STDIN, '<', '/dev/null');
		open(STDOUT, '>&', $key_file) or die "Error: dup failed: $!";
		open(STDERR, '>', '/dev/null');
		exec('openssl', 'genrsa', $nbits);
		die "Error: Unable to run 'openssl genrsa' command: " . ($!{ENOENT} ? 'openssl command not found' : $!) . "\n";
	}
	waitpid($openssl_pid, 0) or die "waitpid failed: $!";
	die "Error: 'openssl genrsa' command failed.\n" unless $? == 0;
}

sub openssl_req {
	my ($key_filename, $dn) = @_;

	my $openssl_req_cnf = make_openssl_req_cnf($dn);
	pipe(my $openssl_reader, my $openssl_writer) or die "Error: pipe failed: $!";
	my $openssl_pid = fork;
	die "Error: fork failed: $!" unless defined $openssl_pid;
	if ($openssl_pid == 0) {
		open(STDIN, '<', '/dev/null');
		open(STDOUT, '>&', $openssl_writer) or die "Error: dup failed: $!";
		close($openssl_reader);
		exec('openssl', 'req', '-new', '-key', $key_filename, '-config', $openssl_req_cnf->filename);
		die "Error: Unable to run 'openssl req' command: " . ($!{ENOENT} ? 'openssl command not found' : $!) . "\n";
	}
	close($openssl_writer);

	my $csr_data = do { local $/; <$openssl_reader> };
	close($openssl_reader);

	waitpid($openssl_pid, 0) or die "Error: waitpid failed: $!";
	die "Error: 'openssl req' command failed - is $key_filename a valid key file?\n" unless $? == 0;

	return $csr_data;
}

sub extract_crt_from_file {
	my ($crt_filename) = @_;

	pipe(my $openssl_reader, my $openssl_writer) or die "Error: pipe failed: $!";
	my $openssl_pid = fork;
	die "Error: fork failed: $!" unless defined $openssl_pid;
	if ($openssl_pid == 0) {
		open(STDIN, '<', '/dev/null');
		open(STDOUT, '>&', $openssl_writer) or die "Error: dup failed: $!";
		close($openssl_reader);
		exec('openssl', 'x509', '-in', $crt_filename, '-subject');
		die "Error: Unable to run 'openssl x509' command: " . ($!{ENOENT} ? 'openssl command not found' : $!) . "\n";
	}
	close($openssl_writer);

	my $crt = '';
	my $cn = undef;
	my $inside_crt = 0;
	while (defined(my $line = <$openssl_reader>)) {
		if ($inside_crt) {
			$crt .= $line;
			$inside_crt = 0 if $line eq "-----END CERTIFICATE-----\n";
		} elsif ($line eq "-----BEGIN CERTIFICATE-----\n") {
			$crt .= $line;
			$inside_crt = 1;
		} else {
			chomp $line;
			if ($line =~ /^subject=\s*(.*\/)?CN=([^\/,]+)/) {
				$cn = $2;
			}
		}
	}
	close($openssl_reader);

	waitpid($openssl_pid, 0) or die "waitpid failed: $!";
	die "Error: 'openssl x509' command failed - is $crt_filename a valid certificate file?\n" unless $? == 0;

	return ($crt, $cn);
}

sub extract_pubkey_from_key {
	my ($key_filename) = @_;

	# The pkey command is only available in OpenSSL 1.0.0 and higher. But older versions of
	# OpenSSL don't support ECC anyways, so it's OK to just use the rsa command instead.
	my $has_pkey_command = grep /^pkey$/, `openssl list-standard-commands`;
	my $pkey_command = $has_pkey_command ? 'pkey' : 'rsa';

	pipe(my $openssl_reader, my $openssl_writer) or die "Error: pipe failed: $!";
	my $openssl_pid = fork;
	die "Error: fork failed: $!" unless defined $openssl_pid;
	if ($openssl_pid == 0) {
		open(STDIN, '<', '/dev/null');
		open(STDOUT, '>&', $openssl_writer) or die "Error: dup failed: $!";
		open(STDERR, '>', '/dev/null') if $pkey_command eq 'rsa'; # rsa command outputs spurious text to stderr
		close($openssl_reader);
		exec('openssl', $pkey_command, '-in', $key_filename, '-pubout', '-outform', 'DER');
		die "Error: Unable to run 'openssl $pkey_command' command: " . ($!{ENOENT} ? 'openssl command not found' : $!) . "\n";
	}
	close($openssl_writer);

	my $pubkey = do { local $/; <$openssl_reader> };
	close($openssl_reader);

	waitpid($openssl_pid, 0) or die "waitpid failed: $!";
	die "Error: 'openssl rsa' command failed - is $key_filename a valid private key file?\n" unless $? == 0;

	return $pubkey;
}

sub wait_for_cert {
	my ($cert_instance_id, $accept_dummy) = @_;

	my $start_time = time;
	my $warn_after = $start_time + 180;
	my $timeout_after = $start_time + 600;
	my $warned = 0;

	while (1) {
		my $now = time;
		my $poll;
		unless ($accept_dummy) {
			if ($now < $warn_after) {
				$poll = $warn_after - $now;
			} elsif ($now < $timeout_after) {
				$poll = $timeout_after - $now;
			} else {
				$poll = 0;
			}

			$poll = 180 if $poll > 180; # upper bound of 180 seconds
		}
		
		my $response = api_call('GET', "/download/$cert_instance_id", { account_id => get_config('account_id'), api_key => get_config('api_key'), poll => $poll, dummy => $accept_dummy });
		return unless defined $response; # TODO: repeat ? b/c this could be a timeout situation

		if ($response->{status} eq 'success') {
			return ($response->{crt}, $response->{chain}, $response->{dummy});
		} elsif ($response->{status} eq 'not_ready') {
			my $now = time;
			my $retry_after = $response->{retry_after};
			if ($now < $warn_after) {
				$retry_after = 1 if $retry_after < 1; # lower bound of 1 second
			} elsif ($now < $timeout_after) {
				if (not $warned) {
					print "Sorry, your certificate isn't ready yet. I'll keep waiting, but if you'd rather do this later, you can hit Ctrl+C and we'll send you an email when it's ready.\n";
					$warned = 1;
				}
				$retry_after = 10 if $retry_after < 10; # lower bound of 10 seconds
			} else {
				# Timed out
				print STDERR "Sorry, your certificate still isn't ready. We'll send you an email when it's ready.\n";
				return;
			}
			sleep($retry_after);
		} elsif ($response->{status} eq 'error') {
			print STDERR "Error: " . $response->{message} . "\n";
			return;
		} else {
			print STDERR "Error: unknown response from server.\n";
			return;
		}
	}
}

sub format_money {
	my ($amount) = @_;
	return sprintf("%.2f", $amount / 100);
}

sub prompt_for_approver_email {
	my ($approver_emails) = @_;

	my $num_emails = int(@$approver_emails);

	my $i = 1;
	for my $email (@$approver_emails) {
		print "$i. $email\n";
		$i++;
	}

	my $mesg = "Enter 1-$num_emails (or q to quit): ";

	while (1) {
		my $answer = prompt_user($mesg);
		if ($answer eq 'q') {
			return undef;
		} elsif ($answer =~ /^\d+$/ and $answer >= 1 and $answer <= $num_emails) {
			return $approver_emails->[$answer - 1];
		} else {
			print "That is not a number between 1 and $num_emails.\n";
		}
	}
}

sub prompt_for_order_confirmation {
	my ($data) = @_;

	print "\n";
	print "============ Order summary ============\n";
	print "      Hostname: " . $data->{cn};
	if ($data->{cn} =~ /^www\.(.*)$/) {
		print " and $1";
	}
	print "\n";
	if ($data->{years} == 1) {
		print "       Product: 1 Year " . ($data->{is_wildcard} ? "Wildcard SSL" : "Standard SSL") . "\n";
		print "         Price: " . format_money($data->{price}) . "\n";
	} else {
		print "       Product: " . ($data->{is_wildcard} ? "Wildcard SSL" : "Standard SSL") . "\n";
		print "         Price: " . format_money($data->{price}) . " / year\n";
		print "         Years: " . $data->{years} . "\n";
	}
	if (defined $data->{auto_renew}) {
		print "    Auto-Renew: " . ($data->{auto_renew} ? "Yes" : "No") . "\n";
	}
	if (defined $data->{approver_email}) {
		print "Approver Email: " . $data->{approver_email} . "\n";
	}
	print "\n";
	print "=========== Payment details ===========\n";
	if ($data->{amount_due}) {
		print "Payment Method: ";
		if ($data->{payment_method} eq 'credit_card') {
			print $data->{cc_type} . " ending in " . $data->{cc_last4};
		} elsif ($data->{payment_method} eq 'balance') {
			print "Account Balance";
		} else {
			print "Other";
		}
		print "\n";
	}
	if ($data->{discount}) {
		print "      Discount: " . format_money($data->{discount}) . " (USD)\n";
	}
	print "    Amount Due: " . format_money($data->{amount_due}) . " (USD)\n";
	print "\n";

	while (1) {
		my $answer = prompt_user('Press ENTER to confirm order (or q to quit): ');
		if ($answer eq '') {
			return 1;
		} elsif ($answer eq 'q') {
			return 0;
		}
	}
}

sub get_dn_from_server {
	my ($cn) = @_;

	my $response = api_call('GET', "/distinguished_name/" . qs_escape($cn),
				{ account_id => get_config('account_id'),
				  api_key => get_config('api_key') });
	return undef unless defined $response;

	if ($response->{status} eq 'success') {
		return $response->{distinguished_name};
	} elsif ($response->{status} eq 'error') {
		print STDERR "Error: " . $response->{message} . "\n";
		return undef;
	} else {
		print STDERR "Error: unknown response from server.\n";
		return undef;
	}
}

sub do_link {
	my ($persistent) = @_;

	print "If you don't have an account yet, visit https://sslmate.com/signup\n";
	my $username = prompt_user("Enter your SSLMate username: ");
	my $password = prompt_password("Enter your SSLMate password: ");
	return 0 if not defined $password;
	if ($persistent) {
		print "Linking account... ";
	} else {
		print "Authenticating... ";
	}
	STDOUT->flush;

	my $response = api_call('POST', '/link', { account_username => $username, account_password => $password });
	return 0 if not defined $response;

	if ($response->{status} eq 'success') {
		if (not defined $response->{api_key} || not defined $response->{country_code}) {
			print STDERR "Error: your account does not have contact details on file.  Please visit https://sslmate.com/account to set your contact details.\n";
			return 0;
		}
		if ($persistent) {
			$personal_config{"account_id"} = $response->{account_id};
			$personal_config{"api_key"} = $response->{api_key};
			save_config;
		} else {
			$ephemeral_config{"account_id"} = $response->{account_id};
			$ephemeral_config{"api_key"} = $response->{api_key};
		}
		print "Done.\n";
		unless ($persistent) {
			print "Tip: if you don't want to have to type your password every time, you can run 'sslmate link' to link this system with your account.\n\n";
		}
		return 1;
	} elsif ($response->{status} eq 'error') {
		print STDERR "Error: " . $response->{message} . "\n";
		return 0;
	} else {
		print STDERR "Error: unknown response from server.\n";
		return 0;
	}
}

sub command_link {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate link\n";
		return 0;
	} elsif (@args > 0) {
		print STDERR "Error: sslmate link takes no arguments.\n";
		print STDERR "Usage: sslmate link\n";
		return 2;
	}

	load_config;

	print "Note: sslmate has already been linked with an account.\nContinue to link it with a different account, or press Ctrl+C to exit.\n" if is_linked;

	do_link(1) or return 1;

	return 0;
}

sub do_wait_for_cert {
	my ($cn, $response, $no_wait, $accept_dummy, $files, $new_key_filename) = @_;

	print "You will soon receive an email at " . $response->{approver_email} . " from " . $response->{approval_from} . ". Follow the instructions in the email to verify your ownership of your domain.\n\n";

	if ($no_wait) {
		print "Once you've verified ownership, you will be able to download your certificate with the 'sslmate download' command.\n";
		return 0;
	} elsif ($accept_dummy) {
		print "Once you've verified ownership, you will be able to download your certificate with the 'sslmate download' command.  In the meantime, you can configure your server with the temporary certificate, but this certificate will NOT be trusted by clients.\n";
	} else {
		print "Once you've verified ownership, your certificate will be automatically downloaded.  If you'd rather do this later, press Ctrl+C and download your certificate with the 'sslmate download' command instead.\n\n";
	}

	print "Waiting for ownership confirmation...\n" unless $accept_dummy;

	my ($crt, $chain_crt, $is_dummy) = wait_for_cert($response->{cert_instance_id}, $accept_dummy) or exit 1;
	$chain_crt //= '';

	write_cert_files($files, $new_key_filename, $crt, $chain_crt);

	print "\n";

	my $extra_info = '';
	if ($is_dummy) {
		print "A temporary, self-signed, certificate has been downloaded.\n\n";
		$extra_info = " (temporary)";
	} else {
		print "Your certificate is ready for use!\n\n";
	}

	print "           Private key file: " . $files->{key_filename} . "\n" if defined $new_key_filename;
	print "           Certificate file: " . $files->{crt_filename} . "$extra_info\n";
	print "     Certificate chain file: " . $files->{chain_crt_filename} . "$extra_info\n";
	print "Certificate with chain file: " . $files->{chained_crt_filename} . "$extra_info\n";
	#print "\n";
	#print "(" . $files->{chained_crt_filename} . " is the concatenation of " . $files->{crt_filename} . " and " . $files->{chain_crt_filename} . "; consult your program's documentation to determine whether you specify the certificate and chain in separate files or in one file.)\n";
	print "\n";
	print "Tip: generate configuration for this cert with the 'sslmate mkconfig' command.\n";
	print "Tip: test this cert's installation by running 'sslmate test $cn'.\n";
}

sub do_buy {
	my ($cn, $years, $force, $no_wait, $accept_dummy, $auto_renew, $batch, $approver_email, %opts) = @_;

	my $dn = get_dn_from_server($cn) or exit 1;
	# Future TODO: support reusing key file if one already exists
	my $files = get_cert_paths($cn, 1);

	check_for_existing_files(@{$files}{qw{key_filename crt_filename chain_crt_filename chained_crt_filename}}) unless $force;

	# Open the key file
	$files->{key_file} = open_key_file($files->{key_filename}, $force);

	my $exit_with_error = sub {
		unlink($files->{key_filename});
		exit 1;
	};

	# 1. Generate an RSA key
	print "Generating private key... "; STDOUT->flush;
	truncate($files->{key_file}, 0);
	openssl_genrsa($files->{key_file}, 2048);
	close($files->{key_file});
	print "Done.\n";

	# 2. Generate the CSR
	print "Generating CSR... "; STDOUT->flush;
	my $csr = openssl_req($files->{key_filename}, $dn);
	print "Done.\n";

	# 3. Buy the certificate from SSLMate
	my $request = { account_id	=> get_config('account_id'),
			api_key		=> get_config('api_key'),
			csr		=> $csr,
			years		=> $years,
			auto_renew	=> $auto_renew,
			approver_email	=> $batch ? $approver_email : undef,
			%opts };

	print "Submitting order...\n";
	my $response = api_call('POST', '/buy', $request) or $exit_with_error->();

	while (not($batch) && $response->{status} eq 'need_confirmation') {
		if ($response->{currency} ne "USD") {
			print STDERR "Error: this version of the sslmate command does not support non-USD currencies. Please download a new version as per the instructions at https://sslmate.com.\n";
			$exit_with_error->();
		}
		if ($response->{cn_is_bare_domain}) {
			my $www_cn = "www.$cn";
			print "\n";
			print "WARNING: This certificate will not be valid for $www_cn.\n";
			print "Would you rather generate a certificate that will work with both $www_cn AND $cn?\n\n";
			if (prompt_yesno) {
				unlink($files->{key_filename});
				return do_buy($www_cn, $years, $force, $no_wait, $accept_dummy, $auto_renew, $batch, $approver_email, %opts);
			}
		}

		unless (defined $approver_email) {
			# Prompt user to choose an approver email and to confirm the order:
			print "\n";
			print "We need to send you an email to verify that you own this domain.\n";
			print "Where should we send this email?\n";
			print "\n";
			$approver_email = prompt_for_approver_email($response->{approver_emails}) or $exit_with_error->();
		}

		prompt_for_order_confirmation($response) or $exit_with_error->();

		# Repeat /buy call with confirmed price and approver email address
		$request->{authorized_charge} = $response->{amount_due};
		$request->{authorized_charge_currency} = $response->{currency};
		$request->{approver_email} = $approver_email;
		print "Placing order...\n";
		$response = api_call('POST', '/buy', $request) or $exit_with_error->();
	}

	if ($response->{status} eq 'error') {
		print STDERR "Error: " . $response->{message} . "\n";
		$exit_with_error->();
	} elsif ($response->{status} ne 'success') {
		print STDERR "Error: unknown response from server\n";
		$exit_with_error->();
	}

	print "Order complete.\n\n";
	return do_wait_for_cert($cn, $response, $no_wait, $accept_dummy, $files, $files->{key_filename});
}

sub command_buy {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate buy [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate buy www.example.com\n";
		print "         sslmate buy '*.example.com'\n";
		print "\n";
		print "Valid options:\n";
		print " -f, --force          overwrite existing files\n";
		print " --auto-renew         automatically renew this certificate before it expires\n";
		print " --no-auto-renew      don't automatically renew this certificate\n";
		print " --batch              don't prompt for confirmation\n";
		print " --email=ADDRESS      use the given approver email address\n";
		print " --no-wait            return immediately; don't wait for cert to be issued\n";
		print " --temp               return immediately with a temporary certificate\n";
		print " --coupon=CODE        use the given coupon code for a discount\n";
		print " --invoice-note=NOTE  include the given note with the invoice\n";
		print " --email-invoice-to=ADDRESS\n";
		print "                      email an invoice to the given address\n";
		return 0;
	}

	my %opts;
	my $auto_renew = undef;
	my $force = 0;
	my $batch = 0;
	my $approver_email = undef;
	my $no_wait = 0;
	my $accept_dummy = 0;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq "--force") {
			$force = 1;
			shift @args;
		} elsif ($args[0] eq "--auto-renew") {
			$auto_renew = 1;
			shift @args;
		} elsif ($args[0] eq "--no-auto-renew") {
			$auto_renew = 0;
			shift @args;
		} elsif ($args[0] =~ /^--coupon=(.*)$/) {
			$opts{coupon_code} = $1;
			shift @args;
		} elsif ($args[0] =~ /^--email-invoice-to=(.*)$/) {
			$opts{email_invoice_to} = $1;
			shift @args;
		} elsif ($args[0] =~ /^--invoice-note=(.*)$/) {
			$opts{invoice_note} = $1;
			shift @args;
		} elsif ($args[0] eq "--batch") {
			$batch = 1;
			shift @args;
		} elsif ($args[0] =~ /^--email=(.*)$/) {
			$approver_email = $1;
			shift @args;
		} elsif ($args[0] eq "--no-wait") {
			$no_wait = 1;
			shift @args;
		} elsif ($args[0] eq "--temp") {
			$accept_dummy = 1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1 && @args != 2) {
		print STDERR "Error: you must specify the hostname for the certificate.\n";
		print STDERR "Example: sslmate buy www.example.com\n";
		print STDERR "     or: sslmate buy '*.example.com'\n";
		print STDERR "See 'sslmate help buy' for help.\n";
		return 2;
	}
	if ($no_wait && $accept_dummy) {
		print STDERR "Error: --no-wait and --temp are mutually exclusive.\n";
		return 2;
	}
	if ($batch && not defined($approver_email)) {
		print STDERR "Error: in batch mode, you must specify the approver email with --email.\n";
		print STDERR "See 'sslmate help buy' for help.\n";
		return 2;
	}

	my $cn = lc $args[0];
	my $years = undef;

	if (@args == 2) {
		$years = $args[1];

		if (!Scalar::Util::looks_like_number($years) || $years < 1 || $years > 5) {
			print STDERR "Error: number of years must be between 1 and 5, inclusive.\n";
			return 1;
		}
	}

	load_config;
	if (!is_linked) {
		if ($batch || not(-t STDIN)) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;
	do_buy($cn, $years, $force, $no_wait, $accept_dummy, $auto_renew, $batch, $approver_email, %opts);
	return 0;
}

sub command_reissue {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate reissue [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate reissue www.example.com\n";
		print "\n";
		print "Valid options:\n";
		print " -f, --force        overwrite existing files\n";
		print " --no-wait          return immediately; don't wait for new cert to be issued\n";
		return 0;
	}

	my $force = 0;
	my $no_wait = 0;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq '--force') {
			$force = 1;
			shift @args;
		} elsif ($args[0] eq "--no-wait") {
			$no_wait = 1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1) {
		print STDERR "Error: you must specify the hostname of the certificate to reissue.\n";
		print STDERR "Example: sslmate reissue www.example.com\n";
		return 2;
	}

	my $cn = $args[0];

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;

	my $dn = get_dn_from_server($cn) or exit 1;
	my $files = get_cert_paths($cn, 1);
	my $new_key_filename = $files->{key_filename} . ".new";

	check_for_existing_files($new_key_filename) unless $force;
	$files->{key_file} = open_key_file($new_key_filename, $force);

	my $exit_with_error = sub {
		unlink($new_key_filename);
		exit 1;
	};

	# 1. Generate an RSA key
	print "Generating private key... "; STDOUT->flush;
	truncate($files->{key_file}, 0);
	openssl_genrsa($files->{key_file}, 2048);
	close($files->{key_file});
	print "Done.\n";

	# 2. Generate the CSR
	print "Generating CSR... "; STDOUT->flush;
	my $csr = openssl_req($new_key_filename, $dn);
	print "Done.\n";

	# 3. Reissue the certificate from SSLMate
	my $request = { account_id	=> get_config('account_id'),
			api_key		=> get_config('api_key'),
			csr		=> $csr };

	print "Reissuing cert...\n";
	my $response = api_call('POST', '/reissue', $request) or $exit_with_error->();

	if ($response->{status} eq 'error') {
		print STDERR "Error: " . $response->{message} . "\n";
		$exit_with_error->();
	} elsif ($response->{status} ne 'success') {
		print STDERR "Error: unknown response from server\n";
		$exit_with_error->();
	}

	print "Reissue complete.\n\n";
	do_wait_for_cert($cn, $response, $no_wait, 0, $files, $new_key_filename);
	return 0;
}

sub command_revoke {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate revoke [-a] HOSTNAME\n";
		print "By default, sslmate revokes all but the most recent certificate for HOSTNAME.\n";
		print "To revoke all certificates, even the most recent, include the -a option.\n";
		return 0;
	}

	my $all = 0;
	while (@args >= 1) {
		if ($args[0] eq "-a" || $args[0] eq "--all") {
			$all = 1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1) {
		print STDERR "Error: you must specify the hostname of the certificate to revoke.\n";
		print STDERR "Example: sslmate revoke www.example.com\n";
		return 2;
	}

	my $cn = $args[0];

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	print "Revoking cert...\n";

	my $response = api_call('POST', '/revoke',
				{ account_id =>	get_config('account_id'),
				  api_key =>	get_config('api_key'),
				  cn =>		$cn,
				  all =>	$all }) or return 1;

	if ($response->{status} eq 'error') {
		print STDERR "Error: " . $response->{message} . "\n";
		return 1;
	} elsif ($response->{status} ne 'success' && $response->{status} ne 'pending') {
		print STDERR "Error: unknown response from server\n";
		return 1;
	}

	if ($response->{num_revoked} == 0 && $response->{num_active} == 0) {
		print STDERR "Error: your account contains no active certificates for '$cn'.\n";
		return 1;
	} elsif ($response->{num_revoked} == 0) {
		print STDERR "Error: the certificate for '$cn' is still in use.\n";
		print STDERR "Before revoking this certificate, please re-issue it by running 'sslmate reissue $cn'.  Alternatively, if you want to revoke this certificate even though it's still in use, pass the -a option to 'sslmate revoke'.\n";
		return 1;
	} else {
		print "Successfully revoked the certificate for $cn.\n";
		print "Please allow up to two business days for this revocation to be processed. You will receive an email when this revocation is complete.\n";
		return 0;
	}
}

sub command_renew {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate renew [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate renew www.example.com\n";
		print "         sslmate renew '*.example.com'\n";
		print "\n";
		print "Valid options:\n";
		print " --batch              don't prompt for confirmation\n";
		print " --no-wait            return immediately; don't wait for new cert to be issued\n";
		print " --coupon=CODE        use the given coupon code for a discount\n";
		print " --invoice-note=NOTE  include the given note with the invoice\n";
		print " --email-invoice-to=ADDRESS\n";
		print "                      email an invoice to the given address\n";
		return 0;
	}

	my %opts;
	my $batch = 0;
	my $no_wait = 0;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq "--force") {
			# Ignored for backwards compatibility with pre-0.5.0
			shift @args;
		} elsif ($args[0] =~ /^--coupon=(.*)$/) {
			$opts{coupon_code} = $1;
			shift @args;
		} elsif ($args[0] =~ /^--email-invoice-to=(.*)$/) {
			$opts{email_invoice_to} = $1;
			shift @args;
		} elsif ($args[0] =~ /^--invoice-note=(.*)$/) {
			$opts{invoice_note} = $1;
			shift @args;
		} elsif ($args[0] eq "--batch") {
			$batch = 1;
			shift @args;
		} elsif ($args[0] eq "--no-wait") {
			$no_wait = 1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1 && @args != 2) {
		print STDERR "Error: you must specify the hostname for the certificate.\n";
		print STDERR "Example: sslmate renew www.example.com\n";
		print STDERR "     or: sslmate renew '*.example.com'\n";
		print STDERR "See 'sslmate help renew' for help.\n";
		return 2;
	}

	my $cn = $args[0];
	my $years = undef;
	if (@args == 2) {
		$years = $args[1];
		if (!Scalar::Util::looks_like_number($years) || $years < 1 || $years > 5) {
			print STDERR "Error: number of years must be between 1 and 5, inclusive.\n";
			return 1;
		}
	}

	load_config;
	if (!is_linked) {
		if ($batch || not(-t STDIN)) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;

	my $files = get_cert_paths($cn, 1);
	my $pubkey_hash = undef;
	if (-f $files->{key_filename} && -r $files->{key_filename}) {
		$pubkey_hash = sha256_hex(extract_pubkey_from_key($files->{key_filename}));
	}

	my $exit_with_error = sub {
		exit 1;
	};

	# Submit the order to SSLMate
	my $request = { account_id	=> get_config('account_id'),
			api_key		=> get_config('api_key'),
			cn		=> $cn,
			pubkey_hash	=> $pubkey_hash,
			years		=> $years,
			%opts };

	print "Submitting order...\n";
	my $response = api_call('POST', '/renew', $request) or $exit_with_error->();

	# TODO: if in batch mode, don't require a second hit to the server to confirm order
	while ($response->{status} eq 'need_confirmation') {
		unless ($batch) {
			if ($response->{currency} ne "USD") {
				print STDERR "Error: this version of the sslmate command does not support non-USD currencies. Please download a new version as per the instructions at https://sslmate.com.\n";
				$exit_with_error->();
			}

			# Prompt user to confirm the order:
			prompt_for_order_confirmation($response) or $exit_with_error->();
		}

		# Repeat /renew call with confirmed price
		$request->{authorized_charge} = $response->{amount_due};
		$request->{authorized_charge_currency} = $response->{currency};
		print STDERR "Placing order...\n";
		$response = api_call('POST', '/renew', $request) or $exit_with_error->();
	}

	if ($response->{status} eq 'error') {
		print STDERR "Error: " . $response->{message} . "\n";
		$exit_with_error->();
	} elsif ($response->{status} ne 'success') {
		print STDERR "Error: unknown response from server\n";
		$exit_with_error->();
	}

	print "Renewal complete.\n\n";
	do_wait_for_cert($cn, $response, $no_wait, 0, $files);
	return 0;
}

sub command_req {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate req [OPTIONS] HOSTNAME\n\n";
		print "Example: sslmate req www.example.com\n";
		print "         sslmate req '*.example.com'\n";
		print "\n";
		print "Valid options:\n";
		print " -f, --force        overwrite existing files\n";
		print " --country=CODE     set country code for request\n";
		return 0;
	}

	my $country_code = 'US';
	my $force = 0;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq "--force") {
			$force = 1;
			shift @args;
		} elsif ($args[0] =~ /^--country=(.*)$/) {
			$country_code = $1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 1) {
		print STDERR "Error: you must specify the hostname for the certificate.\n";
		print STDERR "Example: sslmate req www.example.com\n";
		print STDERR "     or: sslmate req '*.example.com'\n";
		print STDERR "See 'sslmate help req' for help.\n";
		return 2;
	}

	my $cn = lc $args[0];

	# 0. Open the files
	my $open_flags = O_WRONLY | O_CREAT | O_TRUNC;
	$open_flags |= O_EXCL unless $force;
	my $key_file;
	if (!sysopen($key_file, "$cn.key", $open_flags, 0600)) {
		print STDERR "Error: unable to open '$cn.key' for writing: $!\n";
		return 1;
	}
	my $csr_file;
	if (!sysopen($csr_file, "$cn.csr", $open_flags, 0666)) {
		print STDERR "Error: unable to open '$cn.csr' for writing: $!\n";
		return 1;
	}

	# 1. Generate an RSA key
	print "Generating private key... "; STDOUT->flush;
	openssl_genrsa($key_file, 2048);
	close($key_file);
	print "$cn.key\n";

	# 2. Generate the CSR
	print "Generating CSR... "; STDOUT->flush;
	print $csr_file openssl_req("$cn.key", { CN => $cn, C => $country_code, ST => 'Some-State', O => 'Internet Widgits Pty Ltd' });
	close($csr_file);
	print "$cn.csr\n";

	return 0;
}

sub command_download {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate download [OPTIONS] HOSTNAME ...\n";
		print "Example: sslmate download www.example.com\n";
		print "         sslmate download --all\n";
		print "\n";
		print "Valid options:\n";
		print " -a, --all    download certificate for every key in the SSLMate keys directory\n";
		print " --temp       download a temporary certificate if real certificate is not ready\n";
		return 0;
	}

	my $all = 0;
	my $accept_dummy = 0;
	while (@args >= 1) {
		if ($args[0] eq "-a" || $args[0] eq "--all") {
			$all = 1;
			shift @args;
		} elsif ($args[0] eq "--temp") {
			$accept_dummy = 1;
			shift @args;
		} else {
			last;
		}
	}

	if ((!$all && @args == 0) || ($all && @args > 0)) {
		print STDERR "Error: you must specify hostname(s) of certificate(s) to download OR use --all.\n";
		print STDERR "Example: sslmate download www.example.com\n";
		print STDERR "     or: sslmate download --all\n";
		return 2;
	}

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;

	if ($all) {
		# scan the key directory, populate @args for every .key file
		my $key_directory = get_config('key_directory') // '.';
		opendir(my $dh, $key_directory) or die "Error: unable to read key directory: $key_directory: $!\n";
		push @args, map { s/\.key$//; $_ } grep { /\.key$/ } readdir($dh);
		closedir($dh);

		if (@args == 0) {
			print "No certificates to download.\n" unless $quiet;
			return 10;
		}
	}

	my @certs;
	my $errors = 0;
	for my $cn (@args) {
		my $paths = get_cert_paths($cn, 1);

		my $pubkey_hash;
		if (-f $paths->{key_filename} && -r $paths->{key_filename}) {
			$pubkey_hash = sha256_hex(extract_pubkey_from_key($paths->{key_filename}));
		}

		my $has_new_key = 0;
		my $response;
		if (-f $paths->{key_filename} . ".new" && -r $paths->{key_filename} . ".new") {
			# First try to download the cert corresponding to the new key.
			my $new_pubkey_hash = sha256_hex(extract_pubkey_from_key($paths->{key_filename} . ".new"));

			$response = api_call('GET', '/download',
						{ account_id => get_config('account_id'),
						  api_key => get_config('api_key'),
						  cn => $cn,
						  pubkey_hash => $new_pubkey_hash }) or return 1;

			$has_new_key = 1 if $response->{status} eq 'success';
		}
		unless ($has_new_key) {
			$response = api_call('GET', '/download',
						{ account_id => get_config('account_id'),
						  api_key => get_config('api_key'),
						  cn => $cn,
						  dummy => 1,
						  pubkey_hash => $pubkey_hash }) or return 1;
		}
		if ($response->{status} eq 'error') {
			if ($response->{reason} eq 'no_such_cert') {
				print STDERR "Error: $cn: There is no certificate in your account with this name.\n";
				++$errors;
				next;
			} elsif ($response->{reason} eq 'inactive_cert') {
				print STDERR "Error: $cn" . ($pubkey_hash ? " (with private key " . $paths->{key_filename} . ")" : "") . ": " . $response->{message} . "\n";
				++$errors;
				next;
			} elsif ($response->{reason} eq 'no_such_pubkey_hash') {
				print STDERR "Error: $cn: There is no certificate in your account that matches the private key " . $paths->{key_filename} . "\n";
				++$errors;
				next;
			} else {
				print STDERR "Error: $cn: " . $response->{message} . "\n";
				return 1;
			}
		} elsif ($response->{status} ne 'success') {
			print STDERR "Error: unknown response from server when downloading certificate for $cn\n";
			return 1;
		}

		$response->{chain} //= '';

		if (not($has_new_key) &&
				file_contents_are($paths->{crt_filename}, $response->{crt}) &&
				file_contents_are($paths->{chain_crt_filename}, $response->{chain}) &&
				file_contents_are($paths->{chained_crt_filename}, $response->{crt} . $response->{chain})) {

			# Certs did not change
			next;
		}

		if ($response->{dummy} && !$accept_dummy) {
			print STDERR "Error: The certificates for $cn" . ($pubkey_hash ? " (with private key " . $paths->{key_filename} . ")" : "") . " have not yet been issued. Please try again later.\n";
			++$errors;
			next;
		}

		push @certs, { cn => $cn, paths => $paths, response => $response, has_new_key => $has_new_key };
	}

	if (@certs == 0) {
		return 1 if $errors;
		print "All certificate files already downloaded and up-to-date.\n" unless $quiet;
		return 10;
	}

	for my $cert (@certs) {
		my $cn		= $cert->{cn};
		my $paths	= $cert->{paths};
		my $response	= $cert->{response};
		my $has_new_key	= $cert->{has_new_key};

		write_cert_files($paths,
		                 $has_new_key ? $paths->{key_filename} . ".new" : undef,
		                 $response->{crt},
		                 $response->{chain});

		my $extra_info = '';
		if ($response->{dummy}) {
			print "A temporary, self-signed, certificate for $cn has been downloaded.\n\n";
			$extra_info = " (temporary)";
		} else {
			print "The certificate for $cn has been downloaded.\n\n";
		}
		print "           Private key file: " . $paths->{key_filename} . "\n" if -f $paths->{key_filename};
		print "           Certificate file: " . $paths->{crt_filename} . "$extra_info\n";
		print "     Certificate chain file: " . $paths->{chain_crt_filename} . "$extra_info\n";
		print "Certificate with chain file: " . $paths->{chained_crt_filename} . "$extra_info\n";
		print "\n";
	}
	if ($errors) {
		print "Some new certificates were downloaded, but other certificates had errors. See above.\n";
	}
	return 0;
}

sub command_test {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate test [OPTIONS] COMMONNAME\n";
		print "Example: sslmate test www.example.com\n";
		print "\n";
		print "Valid options:\n";
		print " -p, --port=NUMBER   test the given port number (default: 443)\n";
		print " -h, --host=HOSTNAME test the given host (defaults to the common name)\n";
		return 0;
	}

	my $port = 443;
	my @hostname;

	local @ARGV = @args;
	my $getopt = Getopt::Long::Parser->new;
	$getopt->configure(qw(no_ignore_case permute bundling));
	$getopt->getoptions('port|p=i', \$port,
			    'host|h=s', \@hostname) or return 2;

	if (@ARGV == 0) {
		print STDERR "Error: you must specify the name of the certificate to test.\n";
		print STDERR "Example: sslmate test www.example.com\n";
		return 2;
	}

	my $cn = $ARGV[0];

	load_config;
	if (!is_linked) {
		unless (-t STDIN) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	my $response = api_call('GET', '/test/' . qs_escape($cn),
				{ account_id => get_config('account_id'),
				  api_key => get_config('api_key'),
				  port => $port,
				  hostname => \@hostname }) or return 1;

	if ($response->{status} eq 'error') {
		print STDERR "Error: $cn: " . $response->{message} . "\n";
		return 1;
	} elsif ($response->{status} ne 'success') {
		print STDERR "Error: unknown response from server when testing certificate $cn\n";
		return 1;
	}

	if (not @{$response->{result}}) {
		print STDERR "Error: could not resolve hostname.\n";
		print STDERR "To specify a hostname, use the --host option.\n" unless @hostname;
		return 1;
	}

	my $num_errors = 0;
	for my $result (@{$response->{result}}) {
		my $host = $result->{hostname} . " (" . $result->{ip_address} . ")";
		if ($result->{error}) {
			print "$host: Error: " . $result->{error} . "\n";
			++$num_errors;
		} elsif (not $result->{correct}) {
			print "$host: Incorrect certificate installed\n";
			++$num_errors;
		} elsif (not $result->{chained}) {
			print "$host: Chain certificate not installed\n";
			++$num_errors;
		} elsif ($result->{dummy}) {
			print "$host: Good (temporary, self-signed certificate)\n";
		} else {
			print "$host: Good\n";
		}
	}

	return 11 unless $num_errors == 0;
	return 0;
}

sub command_import {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate import [OPTIONS] KEYFILE CERTFILE\n";
		print "\n";
		print "Example: sslmate import www.example.com.key www.example.com.crt\n";
		print "\n";
		print "Valid options:\n";
		print " -f, --force        overwrite existing files\n";
		print " --auto-renew       automatically renew this certificate before it expires\n";
		print " --no-auto-renew    don't automatically renew this certificate\n";
		print " --no-install       don't copy the key/cert to the local key/cert directories\n";
		print " --batch            don't prompt for confirmation\n";
		print " --email=ADDRESS    use the given approver email address\n";
		return 0;
	}

	my $force = 0;
	my $auto_renew = undef;
	my $install = 1;
	my $batch = 0;
	my $approver_email = undef;
	while (@args >= 1) {
		if ($args[0] eq "-f" || $args[0] eq "--force") {
			$force = 1;
			shift @args;
		} elsif ($args[0] eq "--auto-renew") {
			$auto_renew = 1;
			shift @args;
		} elsif ($args[0] eq "--no-auto-renew") {
			$auto_renew = 0;
			shift @args;
		} elsif ($args[0] eq "--no-install") {
			$install = 0;
			shift @args;
		} elsif ($args[0] eq "--batch") {
			$batch = 1;
			shift @args;
		} elsif ($args[0] =~ /^--email=(.*)$/) {
			$approver_email = $1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args != 2) {
		print STDERR "Error: you must specify the key file and cert file paths.\n";
		print STDERR "Example: sslmate import www.example.com.key www.example.com.crt\n";
		return 2;
	}

	if ($batch && not defined($approver_email)) {
		print STDERR "Error: in batch mode, you must specify the approver email with --email.\n";
		print STDERR "See 'sslmate help import' for help.\n";
		return 2;
	}

	# 0. Load config, etc.
	load_config;
	if (!is_linked) {
		if ($batch || not(-t STDIN)) {
			print STDERR "Error: you have not yet linked this system with your SSLMate account.\n";
			print STDERR "Please run 'sslmate link'.\n";
			return 1;
		}
		do_link or return 1;
	}

	init_default_paths;

	do_import($force, $auto_renew, $install, $args[0], $args[1], undef, $batch, $approver_email);
	return 0;
}

sub do_import {
	my ($force, $auto_renew, $install_locally, $source_key_path, $source_crt_path, $cn, $batch, $approver_email) = @_;

	# 1. Read the key
	open(my $source_key_file, '<', $source_key_path) or die "Error: Unable to open $source_key_path: $!\n";
	my $key = do { local $/; <$source_key_file> };
	close($source_key_file);

	# 2. Read the crt
	-f $source_crt_path && -r $source_crt_path or die "Error: No such file: $source_crt_path\n";
	my $crt;
	($crt, defined($cn) ? undef : $cn) = extract_crt_from_file($source_crt_path);
	defined($crt) or die "Error: Unable to parse $source_crt_path - is it a valid certificate file?\n";
	defined($cn) or die "Error: $source_crt_path does not have a common name\n";
	print "Importing certificate for $cn...\n";

	# 3. Generate the CSR
	my $dn = get_dn_from_server($cn) or exit 1;
	my $csr = openssl_req($source_key_path, $dn);

	# 4. Prepare the destination files
	my $files;
	if ($install_locally) {
		$files = get_cert_paths($cn, 1);
		if (realpath($source_key_path) eq realpath($files->{key_filename})) {
			# Don't bother to write the key because it's already in place
			delete $files->{key_filename};
		}
		unless ($force) {
			my @check_files = qw{key_filename chain_crt_filename chained_crt_filename};
			if (realpath($source_crt_path) ne realpath($files->{crt_filename})) {
				# Only care if .crt file exists if it's not the same file we're importing
				push @check_files, 'crt_filename';
			}
			check_for_existing_files(@{$files}{@check_files});
		}

		$files->{key_file} = open_key_file($files->{key_filename}, $force) if defined $files->{key_filename};
	}

	my $exit_with_error = sub {
		unlink($files->{key_filename}) if $install_locally && defined $files->{key_filename};
		exit 1;
	};

	# 5. Upload the CSR and CRT to SSLMate:
	print "Uploading $source_crt_path...\n";
	my $request = { account_id =>	get_config('account_id'),
			api_key =>	get_config('api_key'),
			auto_renew =>	$auto_renew,
			csr =>		$csr,
			crt =>		$crt,
			approver_email => $batch ? $approver_email : undef };
	my $response = api_call('POST', '/import', $request) or $exit_with_error->();

	while (not($batch) && $response->{status} eq 'need_approver_email') {
		if ($response->{cn_is_bare_domain}) {
			my $www_cn = "www.$cn";
			print "\n";
			print "WARNING: This certificate will not be valid for $www_cn when it renews.\n";
			print "Would you rather import a certificate that will work with both $www_cn AND $cn?\n\n";
			if (prompt_yesno) {
				unlink($files->{key_filename}) if $install_locally && defined $files->{key_filename};
				return do_import($force, $auto_renew, $install_locally, $source_key_path, $source_crt_path, $www_cn, $batch, $approver_email);
			}
		}
		if ($response->{has_nondns_sans}) {
			print "\n";
			print "WARNING: This certificate contains non-DNS subject alternative names.\n";
			print "SSLMate does not support non-DNS subject alternative names.  When this\n";
			print "certificate renews, the non-DNS subject alternative names will be dropped.\n\n";
			print "Do you understand and want to import this certificate anyways?\n\n";
			$exit_with_error->() unless prompt_yesno();
		}
		if (@{$response->{disallowed_sans}}) {
			print "\n";
			print "WARNING: This certificate contains the following subject alternative names:\n\n";
			for my $san (@{$response->{disallowed_sans}}) {
				print "\t$san\n";
			}
			print "\nWhen this certificate renews, these subject alternative names will be dropped.\n";
			print "Do you understand and want to import this certificate anyways?\n\n";
			$exit_with_error->() unless prompt_yesno();
		}

		unless (defined $approver_email) {
			# Prompt user to choose an approver email address:
			print "\n";
			print "When it's time to renew this certificate, we will need to send you an email to\n";
			print "verify that you own this domain.  Where should we send this email?\n";
			print "\n";
			$approver_email = prompt_for_approver_email($response->{approver_emails}) or $exit_with_error->();
		}

		# Repeat /import call with approver email address
		$request->{approver_email} = $approver_email;
		$response = api_call('POST', '/import', $request) or $exit_with_error->();
	}

	if ($response->{status} eq 'error') {
		print STDERR "Error: " . $response->{message} . "\n";
		$exit_with_error->();
	} elsif ($response->{status} ne 'success') {
		print STDERR "Error: unknown response from server\n";
		$exit_with_error->();
	}

	# 6. Write the key, crt, and chain to the destination directory
	$response->{chain} //= '';

	if ($install_locally) {
		if (defined $files->{key_file}) {
			# write .key file
			truncate($files->{key_file}, 0);
			print {$files->{key_file}} $key;
			close $files->{key_file};
		}

		write_cert_files($files, undef, $crt, $response->{chain});
	}

	print "\n";
	print "Your certificate has been imported to SSLMate.\n\n";
	if ($install_locally) {
		print "           Private key file: " . ($files->{key_filename} // $source_key_path) . "\n";
		print "           Certificate file: " . $files->{crt_filename} . "\n";
		print "     Certificate chain file: " . $files->{chain_crt_filename} . "\n";
		print "Certificate with chain file: " . $files->{chained_crt_filename} . "\n";
	}
}

sub command_mkconfig {
	local @ARGV = @_;
	my $getopt = Getopt::Long::Parser->new;
	$getopt->configure(qw(no_ignore_case permute bundling));

	my $help_opt = 0;
	my $templates_opt = 0;
	my $no_security_opt = 0;
	$getopt->getoptions('templates', \$templates_opt,
			    'no-security', \$no_security_opt,
			    'help|?', \$help_opt) or return 2;

	if ($help_opt) {
		print "Usage: sslmate mkconfig [--no-security] TEMPLATE COMMONNAME\n";
		print "   or: sslmate mkconfig --templates\n";
		print "Example: sslmate mkconfig apache www.example.com\n";
		print "\n";
		print "Valid options:\n";
		print " --templates    output a list of available config templates\n";
		print " --no-security  don't include recommended security settings\n";
		return 0;
	}

	load_config;
	init_default_paths(0);

	if ($templates_opt) {
		my $response = api_call('GET', '/config_templates') or return 1;
		if ($response->{status} eq 'error') {
			print STDERR "Error: " . $response->{message} . "\n";
			return 1;
		} elsif ($response->{status} ne 'success') {
			print STDERR "Error: unknown response from server\n";
			return 1;
		}

		print join("\n", sort(keys %{$response->{config_templates}}), '');

		return 0;
	}

	if (@ARGV != 2) {
		print STDERR "Error: you must specify the template and certificate name.\n";
		print STDERR "Example: sslmate mkconfig apache www.example.com\n";
		print STDERR "Run 'sslmate help mkconfig' for help.\n";
		return 2;
	}

	my ($template_name, $common_name) = @ARGV;

	my $cmd = '/config_templates/' . qs_escape($template_name);
	$cmd .= '?include_security_settings=1' unless $no_security_opt;
	my $response = api_call('GET', $cmd) or return 1;

	if ($response->{status} eq 'error') {
		if ($response->{reason} // '' eq 'template_not_found') {
			print STDERR "Error: $template_name: Unknown configuration template.\n";
			print STDERR "Run 'sslmate mkconfig --templates' for a list for available templates.\n";
			return 1;
		}

		print STDERR "Error: $template_name: " . $response->{message} . "\n";
		return 1;
	} elsif ($response->{status} ne 'success') {
		print STDERR "Error: unknown response from server\n";
		return 1;
	}

	my $paths = get_cert_paths($common_name, 1);
	my %vars = ('__KEY_PATH__'	=> $paths->{key_filename},
		    '__CERT_PATH__'	=> $paths->{crt_filename},
		    '__CHAIN_PATH__'	=> $paths->{chain_crt_filename},
		    '__CHAINED_PATH__'	=> $paths->{chained_crt_filename});

	my $template = $response->{template};
	for my $var (keys %vars) {
		my $value = $vars{$var};
		$template =~ s/$var/$value/g;
	}

	print $template;
	return 0;
}

sub command_help {
	my @args = @_;

	if (@args == 0 || $args[0] eq 'help') {
		print_usage(*STDOUT);
	} else {
		main($args[0], "-?");
	}
	return 0;
}

sub command_version {
	my @args = @_;

	if (@args >= 1 && $args[0] eq "-?") {
		print "Usage: sslmate version [OPTIONS]\n";
		print "\n";
		print "Valid options:\n";
		print " --no-check         don't check for the latest version\n";
		print " --is-latest        exit non-zero if there is a newer version\n";
		return 0;
	}

	my $check = 1;
	my $is_latest = 0;
	while (@args >= 1) {
		if ($args[0] eq "--no-check") {
			$check = 0;
			shift @args;
		} elsif ($args[0] eq "--is-latest") {
			$is_latest = 1;
			shift @args;
		} else {
			last;
		}
	}
	die "Error: --no-check and --is-latest are mutually-exclusive.\n" if $is_latest && !$check;

	print "SSLMate $VERSION\n" unless $is_latest;
	if ($check) {
		load_config;
		my $response = api_call('GET', '/latest_client_version');

		if (not $response) {
			print STDERR "Error: unable to determine latest available version.\n";
			exit 1 if $is_latest;
		} elsif ($response && $response->{status} eq 'error') {
			print STDERR "Error: unable to determine latest available version: " . $response->{message} . "\n";
			exit 1 if $is_latest;
		} elsif ($response && $response->{status} ne 'success') {
			print STDERR "Error: unable to determine latest available version: unknown response from server\n";
			exit 1 if $is_latest;
		} else {
			if ($VERSION ne $response->{latest_client_version}) {
				exit 10 if $is_latest;
				print "New version of SSLMate available: " . $response->{latest_client_version} . "\n";
			}
		}
	}
	return 0;
}

sub main {
	my @args = @_;

	while (@args >= 1) {
		if ($args[0] eq "-p" && @args >= 2) {
			shift @args;
			$config_profile = $args[0];
			shift @args;
		} elsif ($args[0] =~ /^--profile=(.*)$/) {
			$config_profile = $1;
			shift @args;
		} else {
			last;
		}
	}

	if (@args == 0) {
		print_usage(*STDERR);
		return 2;
	}

	my $command = shift @args;

	if ($command eq 'buy') {
		return command_buy @args;
	} elsif ($command eq 'reissue') {
		return command_reissue @args;
	} elsif ($command eq 'revoke') {
		return command_revoke @args;
	} elsif ($command eq 'renew') {
		return command_renew @args;
	} elsif ($command eq 'req') {
		return command_req @args;
	} elsif ($command eq 'download') {
		return command_download @args;
	} elsif ($command eq 'test') {
		return command_test @args;
	} elsif ($command eq 'import') {
		return command_import @args;
	} elsif ($command eq 'link') {
		return command_link @args;
	} elsif ($command eq 'mkconfig') {
		return command_mkconfig @args;
	} elsif ($command eq 'help') {
		return command_help @args;
	} elsif ($command eq 'version') {
		return command_version @args;
	} else {
		print STDERR "sslmate: '$command' is not a valid sslmate command.  See 'sslmate help'.\n";
		return 1;
	}
}

exit main @ARGV;
